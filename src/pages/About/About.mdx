# [RR Starter-kit 2020](https://rr-starter-kit.netlify.com/)

A front-end starter-kit for quickly getting a new UI up and running using React and Redux Toolkit.

This is an in-depth documentation of the technologies
used in the starter-kit and the reasonings behind them.

## Purpose

A batteries included front-end starter-kit for 2020.
This is my personal go-to set of tools for bootstrapping new projects. It quite a bit more than simply some pre-installed packages and a barebones example, as this covers everything from development experience and CI to Github project management and continuous deployment.

## What's included

The RR Starter-kit itself comes with a fully working example application. React and Redux Toolkit (with Typescript) is at the core of this starter kit. The starter-kit is bootstrapped using Create-React-App, and has not been ejected. As the project uses Typescript, ESLint and Prettier have been configured to handle linting and autofixing syntax problems. The project comes bundled with a simple Github workflow for Continuous Integration and default Github Issues and Pull Request templates.

It is out-of-the-box compatible with deployments to static hosting providers such as Netlify and Zeit.

## Project

This section will go through the development experience related parts of the project, from folder structure to npm scripts, Typescript configurations to linting rules.

### Folder structure

Because the starter-kit is making use of a non-ejected Create-React-App (CRA) as it's foundation everything application related is located within the `src` folder.

```
rr-starter-kit/
  README.md
  node_modules/
  .nvmrc
  .prettierrc
  package.json
  postcss.config.js
  tailwind.config.js
  tsconfig.json
  public/
    _redirects
    index.html
    favicon.ico
  src/
    index.tsx
    tailwind.css
    api/
    app/
      App.tsx
      rootReducer.ts
      store.ts
    components/
    features/
    pages/
```

- `root`: The application starts in `index.tsx` where we initialize the React application and provide it a store using Redux Toolkit:

```
render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root'),
);
```

- `app`: The core of the application is found in the `app` folder.
  Here the `store`, `rootReducer` and `Router` are all configured.
- `api`: This is where the logic to call external services goes.
- `components`: reusable simple components like buttons, alerts etc.
- `features`: more complex features that make us of Redux
- `pages`: navigational pages, the root level component housing the part of the application that lives at that route

### Typescript

The project uses Typescript throughout. Some sensible defaults have been configured in `tsconfig.json`. Most notable addition is using absolute paths for all imports, with `src` as the `baseUrl`. This allows us to do imports throughout the project in the followin way: `import themeReducer from 'features/theme/themeSlice';`. This is more readable and clear than using relative paths.

### ESLint

Extended ESLint to work with Typescript.

```
"eslintConfig": {
    "extends": [
      "eslint:recommended",
      "react-app",
      "plugin:prettier/recommended"
    ],
    "rules": {
      "prettier/prettier": "error"
    }
  },
```

### Prettier

Configured prettier to work correctly with ESLint, autoformatting according to the ESLint rules.

## Stack

### React

There is not much special in the React setup other than the lack of `classes`.
Everything is a component, making use of React `hooks` when needed:

```tsx
export const Header: React.FC = () => {
  // Open mobile menu open
  const [open, setOpen] = useState(false);
  ...
}
```

### Redux Toolkit

Used in the demo example to manage the global state, consisting of the
of the fetched remote data: `jokes` and the global dark mode.

With Redux Toolkit the required boilerplate for Redux is kept at a minimum.
The `createSlice` is a function that accepts an initial state, an object full of reducer functions, and a "slice name", and automatically generates action creators and action types that correspond to the reducers and state.

```ts
const jokesSlice = createSlice({
  name: 'jokes',
  initialState: jokesInitialState,
  reducers: {
    getJokesStart: startLoading,
    getJokesSuccess(state, { payload }: PayloadAction<Jokes>) {
      const { jokes } = payload;
      state.jokes = jokes;
      state.isLoading = false;
      state.error = null;
    },
    getJokesFailure: loadingFailed,
  },
});
```

### Axios

Axios is used in favor of `fetch` to interface with any external services.
All outgoing request logic is located in the `api` folder.

```ts
export async function getRandomJokes(): Promise<Jokes> {
  const url = `https://official-joke-api.appspot.com/jokes/ten`;

  const jokesResponse = await axios.get<Joke[]>(url);
  return { jokes: jokesResponse.data };
}
```

We are using `redux-thunk` to handle dispatching of async actions.
Here the `fetchJokes` function is using `async / await` to handle the fetching of remote data:

```ts
export const fetchJokes = (): AppThunk => async dispatch => {
  try {
    dispatch(getJokesStart());
    const randomJokes = await getRandomJokes();
    dispatch(getJokesSuccess(randomJokes));
  } catch (err) {
    dispatch(getJokesFailure(err.toString()));
  }
};
```

### Tailwind CSS

## Testing

### Jest

### Enzyme

### Debugging

## CI/CD

### Github Actions

Github actions for CI

### Auto Deployment

Auto deployment to Netlify

## RR Starter-kit Example App

### Async Data

### Utility-first CSS

### Dark mode

### MDX

### Icons / Images
